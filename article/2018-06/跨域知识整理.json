{"name":"跨域知识整理","keywords":"CORS,jsonp","createAt":"2018-6-6","updateAt":"","brief":"<p>整理一下jsonp和CORS的知识</p>\n","content":"<!--keywords:CORS,jsonp-->\n<!--create:2018-6-6-->\n<p>整理一下jsonp和CORS的知识。</p>\n<h2 id=\"jsonp\">jsonp</h2>\n<h3 id=\"-\">前端代码</h3>\n<pre><code>function jsonpHandler (res) {\n    console.log(&#39;jsonpHandler got: &#39; + res)\n    console.log(&#39;jsonpHandler got a: &#39; + res.a)\n}\nvar scriptTag = document.createElement(&#39;script&#39;)\n// callback参数必须有\nscriptTag.src = &#39;http://127.0.0.1:8888/jsonp-test?callback=jsonpHandler&amp;a=1&amp;b=2&#39;\ndocument.body.appendChild(scriptTag)\n</code></pre><h3 id=\"-node-js-express-\">服务器代码(以下均为node.js与express框架代码)</h3>\n<pre><code>service.get(&#39;/jsonp-test&#39;, (req, res) =&gt; {\n    console.log(req.query)\n    res.jsonp({a:1})\n})\n</code></pre><h3 id=\"-\">原理</h3>\n<p>前端动态创建script元素，设置src，通过script元素发出了get请求；</p>\n<p>服务器收到了get请求后，解析请求中的参数，并返回一个js文件，内容如下：</p>\n<pre><code>/**/ typeof jsonpHandler === &#39;function&#39; &amp;&amp; jsonpHandler({&quot;a&quot;:1});\n</code></pre><p>浏览器会自动执行上面这段代码。</p>\n<h3 id=\"-\">适用范围</h3>\n<p>几乎支持所有的浏览器；</p>\n<p>仅能发出get请求；</p>\n<p>调用失败时，没有各种http状态码返回，需要自行处理是否超时；</p>\n<h3 id=\"-\">安全问题</h3>\n<p>jsonp不受同源策略的限制，安全问题比较多；</p>\n<p>提供jsonp服务的服务器要做好csrf的防御，应该仅在无法使用CORS的情况下使用。</p>\n<h2 id=\"cors-cross-origin-resource-sharing-\">CORS (Cross-Origin Resource Sharing 跨域资源共享)</h2>\n<p>使用CORS技术跨域时，http请求被分为简单请求和需预检的请求，详细请查看<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">cors</a>。</p>\n<h3 id=\"-\">简单请求</h3>\n<h4 id=\"-\">前端代码</h4>\n<pre><code>// 使用ajax发出一个get请求\nvar xmlHttp = new XMLHttpRequest()\nxmlHttp.open(&#39;get&#39;, &#39;http://localhost:8888/service&#39;, true)\nxmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {\n        console.log(xmlHttp.responseText)\n    }\n}\nxmlHttp.send()\n</code></pre><h4 id=\"-\">服务端代码</h4>\n<pre><code>function crossOrigin(req, res, next) {\n    // 浏览器对跨域的请求(简单和预检都有)会在http头中加入Origin字段\n    // 服务端对此进行判断，决定是否允许跨域\n    let reqOrigin = req.header(&#39;Origin&#39;)\n    if (reqOrigin &amp;&amp; reqOrigin.indexOf(&#39;http://localhost:8080&#39;) &gt; -1) {\n        // 设置响应头，否则会被浏览器拦截\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://localhost:8080&#39;)\n    } else {\n        res.sendStatusCode(403)\n        return\n    }\n    next()\n}\n\nservice.use(crossOrigin)\n\nservice.get(&#39;/service&#39;, (req, res) =&gt; {\n    res.json({ a: 1 })\n})\n</code></pre><h4 id=\"-\">原理</h4>\n<p>浏览器发出一个简单请求到服务器，服务器判断请求的Origin字段是否符合条件；\n针对符合条件的请求，设置响应头相关字段，返回给浏览器。</p>\n<h3 id=\"-\">需预检的请求</h3>\n<h4 id=\"-\">前端代码</h4>\n<pre><code>// 使用ajax技术发出了一个put请求，并且设置了自定义请求头\nvar xmlHttp = new XMLHttpRequest()\nxmlHttp.open(&#39;put&#39;, &#39;http://localhost:8888/service&#39;, true)\nxmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {\n        console.log(xmlHttp.responseText)\n    }\n}\nxmlHttp.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;23333&#39;)\nxmlHttp.send()\n</code></pre><h4 id=\"-\">服务器端代码</h4>\n<pre><code>function crossOrigin(req, res, next) {\n    // 浏览器对跨域的请求(简单和预检都有)会在http头中加入Origin字段\n    // 服务端对此进行判断，决定是否允许跨域\n    let reqOrigin = req.header(&#39;Origin&#39;)\n    if (reqOrigin &amp;&amp; reqOrigin.indexOf(&#39;http://localhost:8080&#39;) &gt; -1) {\n        // 设置响应头，否则会被浏览器拦截\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://localhost:8080&#39;)\n    } else {\n        res.sendStatusCode(403)\n        return\n    }\n    next()\n}\n\nservice.use(crossOrigin)\n\n// 针对浏览器的预检请求的处理\nservice.options(&#39;/service&#39;, (req, res, next) =&gt; {\n    // 检查Access-Control-Request-Method字段\n    let reqMethod = req.header(&#39;Access-Control-Request-Method&#39;)\n    let allowMethods = [&#39;GET&#39;, &#39;POST&#39;, &#39;PUT&#39;, &#39;DELETE&#39;]\n    if (!reqMethod || allowMethods.indexOf(reqMethod) === -1){\n        next()\n        return\n    }\n    // 检查Access-Control-Request-Headers字段\n    let reqHeaders = req.header(&#39;Access-Control-Request-Headers&#39;)\n    let allowHeaders = [&#39;x-custom-header&#39;]\n    if (!reqHeaders || allowHeaders.indexOf(reqHeaders) === -1) {\n        next()\n        return\n    }\n\n    // 设置响应头相关字段，否则会被浏览器拦截\n    res.header(&#39;Access-Control-Allow-Methods&#39;, allowMethods.join()) // 允许跨域的请求类型\n    res.header(&#39;Access-Control-Allow-Headers&#39;, allowHeaders.join()) // 允许跨域的自定义请求头\n\n    // 设置本次预检的有效期，单位为秒，表示在该时间段内浏览器不再需要发出预检(options)请求\n    res.header(&#39;Access-Control-Max-Age&#39;, 3600 * 24 * 30)\n    next()\n})\n\nservice.put(&#39;/service&#39;, (req, res) =&gt; {\n    res.json({ a: 1 })\n})\n</code></pre><h4 id=\"-\">原理</h4>\n<p>浏览器检测到需要预检，所以发出一个预检(options)请求；\n服务器收到预检请求，检测请求头的Origin、Access-Control-Request-Methods等字段是否符合要求；\n针对符合要求的请求，服务器会设置响应头的相关字段，返回给浏览器;\n浏览器验证通过后，会发出原始的put请求</p>\n<h3 id=\"-\">适用范围</h3>\n<p>IE版本 &gt;= 10；\nREST跨域。</p>\n<h3 id=\"-\">安全性</h3>\n<p>需要配置好Access-Control-Allow-Origin的值，偷懒用*就GG了;</p>\n"}