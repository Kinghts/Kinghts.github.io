{"name":"写给前端看的Flutter备忘录程序","keywords":"Flutter,备忘录","createAt":"2018-11-8","updateAt":"2018-12-31 10:21:59","brief":"<p><a href=\"https://flutter.io/\">Flutter</a>是Google推出的移动UI框架，可以快速构建iOS和Android的原生用户界面。由于其使用的dart语言语法简单(???)，开发调试容易，且相对原有的iOS和Android原生开发较简单，所以在今年推出了Beta版本后，国内就炒得火热。其项目结构借鉴了一些React的思想，dart语法与javascript语法看起来相近，所以也适合前端人员上手</p>\n","content":"<!--keywords:Flutter,备忘录-->\n<!--create:2018-11-8-->\n<p><a href=\"https://flutter.io/\">Flutter</a>是Google推出的移动UI框架，可以快速构建iOS和Android的原生用户界面。由于其使用的dart语言语法简单(???)，开发调试容易，且相对原有的iOS和Android原生开发较简单，所以在今年推出了Beta版本后，国内就炒得火热。其项目结构借鉴了一些React的思想，dart语法与javascript语法看起来相近，所以也适合前端人员上手。</p>\n<h2 id=\"-\">前言</h2>\n<p><a href=\"https://flutter.io/\">Flutter</a>是Google推出的移动UI框架，可以快速构建iOS和Android的原生用户界面。由于其使用的dart语言语法简单(???)，开发调试容易，且相对原有的iOS和Android原生开发较简单，所以在今年推出了Beta版本后，国内就炒得火热。其项目结构借鉴了一些React的思想，dart语法与javascript语法看起来相近，所以也适合前端人员上手。</p>\n<h2 id=\"-\">开发环境配置</h2>\n<p>具体配置请参考<a href=\"https://flutterchina.club/get-started/install/\">中文教程</a></p>\n<p>本文档介绍的备忘录程序在vscode上开发，使用Android Studio自带的安卓模拟器运行。</p>\n<h2 id=\"-\">备忘录程序的结构</h2>\n<p>程序的页面就两个，列表页和详情页：</p>\n<p><img src=\"./img/app-structure.png\" alt=\"img\"></p>\n<p>简单来说就是一个带新增和编辑功能的todo list。</p>\n<h3 id=\"-\">列表页</h3>\n<p><img src=\"./img/list-view.png\" alt=\"img\"></p>\n<h3 id=\"-\">详情页</h3>\n<p><img src=\"./img/detail-view.png\" alt=\"img\"></p>\n<h2 id=\"-\">项目的文件结构</h2>\n<p><img src=\"./img/project-files.png\" alt=\"img\"></p>\n<p>简单介绍下项目的文件：</p>\n<p>项目根目录下的pubspec.yaml管理了项目的依赖库，类似npm生成的package.json；</p>\n<p>lib文件夹里的文件是程序的主要代码：</p>\n<p>lib/main.dart 是程序的入口文件，包含了备忘录的列表页；</p>\n<p>lib/file.dart 包含了一个读写文件的类；</p>\n<p>lib/detail_page.dart 是备忘录的详情页。</p>\n<h2 id=\"lib-main-dart-\">lib/main.dart代码解读</h2>\n<h3 id=\"-\">程序的入口</h3>\n<pre><code class=\"lang-Dart\">void main() =&gt; runApp(new MyApp()); // runApp是引入的flutter依赖库中的方法\n</code></pre>\n<p>Flutter使用的是Dart语言，Dart程序必须有个void main() {}方法作为入口才能运行。</p>\n<p>在Dart语言中，函数写成一行时，可以使用类似ES6里的箭头函数缩写，所以有上述写法。</p>\n<pre><code class=\"lang-Dart\">class MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: &#39;Startup Name Generator&#39;,\n      home: MyHome()\n    );\n  }\n}\n</code></pre>\n<h3 id=\"widget\">widget</h3>\n<p>在Flutter中，有个widget的概念，可以理解为类似vue里的组件。\n通过widget的嵌套和组合，就可以构成一个App。\nwidget分为StatelessWidget和StatefulWidget，从字面意思就可以猜到，一个是无状态widget，一个是有状态widget。\n这里MyApp是一个StatelessWidget，它的内部嵌套了一个MyHome widget。</p>\n<pre><code class=\"lang-Dart\">class MyHome extends StatefulWidget {\n  @override\n  createState() =&gt; new HomeState();\n}\n\nclass HomeState extends State&lt;MyHome&gt; {\n  Map _map = new Map();\n  ...\n}\n</code></pre>\n<p>MyHome是有状态的widget，它有个保存状态的变量_map，_map中的内容就是列表页的列表数据。</p>\n<h3 id=\"widget-\">widget的生命周期钩子</h3>\n<pre><code class=\"lang-Dart\">@override\n    void initState() {\n      super.initState();\n      print(&#39;home init&#39;);\n      // map.json文件，初始化_map\n      FileOperation.readFile(&#39;map.json&#39;).then((String str) {\n        if (str.length &gt; 0) {\n          try {\n            _map = json.decode(str);\n            print(_map);\n          } on FormatException {\n            print(&#39;不是json格式&#39;);\n          }\n        }\n      });\n    }\n</code></pre>\n<p>initState类似vue里组件的created钩子，在widget初始化时执行一次。</p>\n<pre><code class=\"lang-Dart\">@override\n  Widget build(BuildContext context) {\n    ...\n  }\n</code></pre>\n<p>build类似vue里的render方法，告诉程序如何渲染界面，在widget的状态发生改变时，会立即执行。\n完整的生命周期介绍可以参考：<a href=\"https://flutterbyexample.com/stateful-widget-lifecycle/\">Lifecycle</a>。</p>\n<h3 id=\"-\">路由跳转</h3>\n<pre><code class=\"lang-Dart\">// 跳转到详情页\nNavigator.of(context).push(new MaterialPageRoute(builder: (_) {\n  return DetailPage(path: k, content: v[&#39;content&#39;], callback: callback,);\n}));\n</code></pre>\n<p>Flutter中有两种路由，静态路由和动态路由，这里使用了动态路由。</p>\n<h2 id=\"lib-detail_page-dart-\">lib/detail_page.dart代码解读</h2>\n<h3 id=\"-widget-widget-\">父widget给子widget传参数</h3>\n<pre><code class=\"lang-Dart\">class DetailPage extends StatefulWidget {\n  ...\n  final String path;\n  final String content;\n  final Function(String, String) callback;\n\n  const DetailPage({ // 构造函数\n    Key key,\n    this.path,\n    this.content,\n    this.callback\n  }):super(key: key);\n}\n\nclass DetailState extends State&lt;DetailPage&gt; {\n  String _path = &#39;&#39;;\n  String _content = &#39;&#39;;\n  ...\n  setState(() { // 初始化本地状态\n    _path = widget.path;\n    _content = widget.content;\n  });\n  ...\n}\n</code></pre>\n<p>DetailPage也是一个有状态的widget，主要状态是_path和_content，对应_map中的key和值{ &#39;content&#39;: &#39;&#39; },\n这两个状态的初始值由列表页传递过来，直接写在构造函数中即可。</p>\n<h3 id=\"-widget-widget-\">子widget给父widget传参数</h3>\n<p>Flutter并不直接支持这种传参数的方式(强烈要求支持全局状态管理)，所以需要使用callback大法。</p>\n<p>lib/main.dart中</p>\n<pre><code class=\"lang-Dart\">...\ncallback(p, c) {\n  print(&#39;$p $c&#39;);\n  print(_map);\n  setState(() {\n    _map[p][&#39;content&#39;] = c;\n  });\n}\n...\nreturn DetailPage(path: k, content: v[&#39;content&#39;], callback: callback); // callback作为参数传给了子widget\n...\n</code></pre>\n<p>lib/detain_page.dart中</p>\n<pre><code class=\"lang-Dart\">@override\n  void deactivate() { // 点击返回箭头后，详情页不再展示，会执行这个钩子函数\n    print(&#39;deactivate&#39;);\n    widget.callback(_path, _content); // 调用callback，就修改了父组件的_map了\n    super.deactivate();\n  }\n</code></pre>\n"}